
\chapter{Függelék}


%----------------------------------------------------------------------------
\section{Matlab szimulátor}
%----------------------------------------------------------------------------
\texttt{feszko.m }
\begin{lstlisting}[frame=single]  % Start your code-block

clear all; close all; clc;

L = 1;

N = 500;
dx = L / N;

f0 = 0;
f1 = 1;

IT = 10000;

%%

fi = zeros(IT, N);
fi(:, 1) = f0 * ones(IT, 1);
fi(:, end) = f1 * ones(IT, 1);

T = zeros(N, N);
for n = 2:N-1
    T(n-1, n) =  0.5;
    T(n+1, n) =  0.5;
end
T(1,1) = 1;
T(end,end) = 1;

tic

for i = 2:IT
   fi(i, :) =  fi(i-1, :) * T;
end

toc

figure;
ax1 = subplot(211);
plot(linspace(0, L, N), fi(end, :)); grid;
xlabel('x');
ylabel('phi(x)');
title('Potencial eloszlas az iteracio vegen');

ax2 = subplot(212);
plot(linspace(0, L, N-1), diff(fi(end, :)) ./ dx);  grid;
xlabel('x');
ylabel('E(x)');
title('Elektromos ter az iteracio vegen');

linkaxes([ax1 ax2], 'x');

mfig(fi(1:1000:IT,1:4:N), 1:1000:IT,1:4:N)
\end{lstlisting}

\texttt{feszko2D.m }
\begin{lstlisting}[frame=single]  % Start your code-block

clear all; close all; clc;

X = 500;
Y = 500;

% mindig oszthato legyen 2vel
%global NX NY;
NX = 12;
NY = 12;

dx = X / NX;
dy = Y / NY;

f0 = 0;
f1 =1;


IT = 20000;

%%
ij2n = ((ones(NY,1) * (1:NX)) + ((0:NX:NX*(NY-1))' * ones(1,NX)))';


index = zeros(NX, NY);

index( 1: NX/4, NY/4+1:end) = -5;
index((3*NX/4)+1:end, 1: 3*NY/4) = -5;

index(1: 3*NX/4, 1) = -2;
index(3*NX/4, 1: 3*NY/4) = -6;
index(3*NX/4:end, (3*NY/4)+1) = -2;
index(end, (3*NY/4)+1 : end) = -6;
index((NX/4)+1:end, end) = -8;
index((NX/4)+1, NY/4:end) = -4;
index(1:NX/4, NY/4) = -8;
index(1, 1: NY/4) = -4;

index(3*NX/4,1) = -3;
index(3*NX/4,(3*NY/4)+1) = -3;

index((NX/4)+1,NY/4) = -7;
index((NX/4)+1,end) = -7;

index(1, 1:NY/4) = -10;
index(end, (3*NY/4)+1:end) = -11;


flip(index', 1)
flip(ij2n', 1)

%%
T = zeros(NX*NY, NX*NY);
[ii, jj] = find(index == 0);

for n = 1: length(ii)
    nn = ij2n(ii(n), jj(n));
    T(ij2n(ii(n)+1, jj(n)  ) , nn ) = 0.25;
    T(ij2n(ii(n)  , jj(n)+1) , nn ) = 0.25;
    T(ij2n(ii(n)-1, jj(n)  ) , nn ) = 0.25;
    T(ij2n(ii(n)  , jj(n)-1) , nn ) = 0.25;
end

valind = [ 1  1;
        0  1;
       -1  1;
        1  0;
        NaN NaN;
       -1  0;
        1 -1;
        0 -1;
       -1 -1];
        

% mi mivel
m = 1;
for i = 1:NX
    for j=1:NY
        if(-10 < index(i,j) & index(i,j) < 0 & index(i,j) ~= -5)
            mm(m, 1) = ij2n(i,j);
            mm(m, 2) = ij2n(i+valind(-index(i,j),1), j+valind(-index(i,j),2));
            m = m + 1;
        end
    end
end

f00 = find(reshape(index, 1, []) == -10);
f11 = find(reshape(index, 1, []) == -11);

%%
fi = zeros(IT, NX*NY);
% dirich
   for m= 1:length(f00)
       fi(1, f00(m)) = f0;
   end
   for m= 1:length(f11)
       fi(1, f11(m)) = f1;
   end

tic

for i = 2:IT
   fi(i, :) =  fi(i-1, :) * T;
   for m=1:length(mm)
       fi(i, mm(m, 1)) = fi(i, mm(m, 2));
   end
   % dirich
   for m= 1:length(f00)
       fi(i, f00(m)) = f0;
   end
   for m= 1:length(f11)
       fi(i, f11(m)) = f1;
   end
end

toc

fii = zeros(NX,NY, IT);
for i= 1:IT
    fii(:,:, i) = reshape(fi(i, :), NX, NY);
end



%%
fii( 1: NX/4, NY/4+1:end, end) = NaN;
fii((3*NX/4)+1:end, 1: 3*NY/4, end) = NaN;

figure;
ax1 = subplot(211);
contourf(fii(:,:,end)');
xlabel('x');
ylabel('y');
title('Potencial eloszlas az iteracio vegen');

ax2 = subplot(212);
contourf(diff(fii(:,:,end))');
xlabel('x');
ylabel('y');
title('Elektromos ter az iteracio vegen');

linkaxes([ax1 ax2], 'x');

%%


figm = figure('Renderer','zbuffer');
contourf(fii(:,:,2)'); title('0');
axis tight
set(gca,'NextPlot','replaceChildren');
% Preallocate the struct array for the struct returned by getframe
F(200) = struct('cdata',[],'colormap',[]);
% Record the movie
for j = 1:200
    fii( 1: NX/4, NY/4+1:end, j*100) = NaN;
    fii((3*NX/4)+1:end, 1: 3*NY/4, j*100) = NaN;
    surf(fii(:,:,j*100)');
    title(['it = ' num2str(j*100)]);
    xlabel('N'); ylabel('IT');
    
    %contourf(fii(:,:,j*100)'); 
    F(j) = getframe;
end


figure;
movie(F, 2)
\end{lstlisting}


\texttt{main.cu}
\begin{lstlisting}[frame=single]  % Start your code-block

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#include <helper_functions.h>
#include <helper_cuda.h>


extern "C"
void CPU(
    float *h_C,
    float *h_A,
    float *h_B,
    int vectorN,
    int elementN
);



#include "kernel.cuh"


float RandFloat(float low, float high)
{
    float t = (float)rand() / (float)RAND_MAX;
    return (1.0f - t) * low + t * high;
}



///////////////////////////////////////////////////////////////////////////////
// Data configuration
///////////////////////////////////////////////////////////////////////////////

const int VECTOR_N = 456;
const int ELEMENT_N = 4096;

const int    DATA_N = VECTOR_N * ELEMENT_N;

const int   DATA_SZ = DATA_N * sizeof(float);
const int RESULT_SZ = VECTOR_N  * sizeof(float);



///////////////////////////////////////////////////////////////////////////////
// Main program
///////////////////////////////////////////////////////////////////////////////
int main(int argc, char **argv)
{
    float *h_A, *h_B, *h_C_CPU, *h_C_GPU;
    float *d_A, *d_B, *d_C;
    //double delta, ref, sum_delta, sum_ref, L1norm;
    StopWatchInterface *hTimer = NULL;
    int i;


	getchar();

    printf("%s Starting...\n\n", argv[0]);

    // use command-line specified CUDA device, otherwise use device with highest Gflops/s
    findCudaDevice(argc, (const char **)argv);

    sdkCreateTimer(&hTimer);

    printf("Initializing data...\n");
    printf("...allocating CPU memory.\n");
    h_A     = (float *)malloc(DATA_SZ);
    h_B     = (float *)malloc(DATA_SZ);
    h_C_CPU = (float *)malloc(RESULT_SZ);
    h_C_GPU = (float *)malloc(RESULT_SZ);

    printf("...allocating GPU memory.\n");
    checkCudaErrors(cudaMalloc((void **)&d_A, DATA_SZ));
    checkCudaErrors(cudaMalloc((void **)&d_B, DATA_SZ));
    checkCudaErrors(cudaMalloc((void **)&d_C, RESULT_SZ));

    printf("...generating input data in CPU mem.\n");
    srand(123);

    //Generating input data on CPU
    for (i = 0; i < DATA_N; i++)
    {
        h_A[i] = RandFloat(0.0f, 1.0f);
        h_B[i] = RandFloat(0.0f, 1.0f);
    }

    printf("...copying input data to GPU mem.\n");
    //Copy options data to GPU memory for further processing
    checkCudaErrors(cudaMemcpy(d_A, h_A, DATA_SZ, cudaMemcpyHostToDevice));
    checkCudaErrors(cudaMemcpy(d_B, h_B, DATA_SZ, cudaMemcpyHostToDevice));
    printf("Data init done.\n");


    printf("Executing GPU kernel...\n");
    checkCudaErrors(cudaDeviceSynchronize());
    sdkResetTimer(&hTimer);
    sdkStartTimer(&hTimer);
    GPU<<<128, 256>>>(d_C, d_A, d_B, VECTOR_N, ELEMENT_N);
    getLastCudaError("scalarProdGPU() execution failed\n");
    checkCudaErrors(cudaDeviceSynchronize());
    sdkStopTimer(&hTimer);
    printf("GPU time: %f msecs.\n", sdkGetTimerValue(&hTimer));

    printf("Reading back GPU result...\n");
    //Read back GPU results to compare them to CPU results
    checkCudaErrors(cudaMemcpy(h_C_GPU, d_C, RESULT_SZ, cudaMemcpyDeviceToHost));


    printf("Checking GPU results...\n");
    printf("..running CPU scalar product calculation\n");

	sdkResetTimer(&hTimer);
    sdkStartTimer(&hTimer);
    CPU(h_C_CPU, h_A, h_B, VECTOR_N, ELEMENT_N);
	 sdkStopTimer(&hTimer);
    printf("cPU time: %f msecs.\n", sdkGetTimerValue(&hTimer));


    
    exit(EXIT_SUCCESS);
}
\end{lstlisting}


\texttt{kernel.cuh}
\begin{lstlisting}[frame=single]  % Start your code-block

#define IMUL(a, b) __mul24(a, b)



#define ACCUM_N 1024
__global__ void GPU(
    float *d_C,
    float *d_A,
    float *d_B,
    int vectorN,
    int elementN
)
{
    //Accumulators cache
    __shared__ float accumResult[ACCUM_N];

    for (int vec = blockIdx.x; vec < vectorN; vec += gridDim.x)
    {
        int vectorBase = IMUL(elementN, vec);
        int vectorEnd  = vectorBase + elementN;

        for (int iAccum = threadIdx.x; iAccum < ACCUM_N; iAccum += blockDim.x)
        {
            float sum = 0;

            for (int pos = vectorBase + iAccum; pos < vectorEnd; pos += ACCUM_N)
                sum += d_A[pos] * d_B[pos];

            accumResult[iAccum] = sum;
        }

        for (int stride = ACCUM_N / 2; stride > 0; stride >>= 1)
        {
            __syncthreads();

            for (int iAccum = threadIdx.x; iAccum < stride; iAccum += blockDim.x)
                accumResult[iAccum] += accumResult[stride + iAccum];
        }

        if (threadIdx.x == 0) d_C[vec] = accumResult[0];
    }
}
\end{lstlisting}
